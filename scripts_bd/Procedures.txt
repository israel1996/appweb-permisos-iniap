

DELIMITER $$
CREATE PROCEDURE pa_insertEmployee(
    IN p_id_codeType INT,
    IN p_id_typeContract INT,
    IN p_id_departament INT,
    IN p_id_jobTitle INT,
    IN p_ci_employee VARCHAR(13),
    IN p_name_employee VARCHAR(100),
    IN p_lastName_employee VARCHAR(150),
    IN p_startDate_employee DATE,
    IN p_phoneNumber_employee VARCHAR(13),
    IN p_address_employee TEXT,
    IN p_email_employee VARCHAR(100),
    IN p_salary_employee DECIMAL(10,2),
    OUT p_success BOOLEAN,
    OUT p_message TEXT
)
BEGIN
    DECLARE ciExists INT DEFAULT 0;
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_success = FALSE;
        SET p_message = CONCAT('Error en la transacción: ', SUBSTRING_INDEX(SUBSTRING_INDEX(LEFT(NEW.MESSAGE, 100), ' at ', -1), ':', 1));
    END;

    -- Verificar si el número de cédula ya existe
    SELECT COUNT(*) INTO ciExists FROM tb_employee WHERE ci_employee = p_ci_employee;

    IF ciExists > 0 THEN
        SET p_success = FALSE;
        SET p_message = 'Ya existe un empleado con ese número de cédula';
    ELSE
        START TRANSACTION;
        -- Inserción en la tabla tb_employee
        INSERT INTO tb_employee (id_codeType, id_typeContract, id_departament, id_jobTitle, ci_employee, name_employee, lastName_employee, startDate_employee, phoneNumber_employee, address_employee, email_employee, salary_employee)
        VALUES (p_id_codeType, p_id_typeContract, p_id_departament, p_id_jobTitle, p_ci_employee, p_name_employee, p_lastName_employee, p_startDate_employee, p_phoneNumber_employee, p_address_employee, p_email_employee, p_salary_employee);

        COMMIT;

        SET p_success = TRUE;
        SET p_message = 'Inserción exitosa';
    END IF;
END $$
DELIMITER ;



DELIMITER $$
CREATE PROCEDURE pa_insertUser(
    IN p_id_employee INT,
    IN p_id_userType INT,
    IN p_password_user VARCHAR(200),
    OUT p_success BOOLEAN,
    OUT p_message TEXT
)
BEGIN
    DECLARE username VARCHAR(255);
    DECLARE counter INT DEFAULT 0;
    DECLARE usernameExists INT DEFAULT 0;
    DECLARE p_name_employee_n VARCHAR(255);
    DECLARE p_lastName_employee_n VARCHAR(255);
    DECLARE p_name_employee VARCHAR(255);
    DECLARE p_lastName_employee VARCHAR(255);
    DECLARE ciExists INT DEFAULT 0;
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_success = FALSE;
        SET p_message = CONCAT('Error en la transacción: ', SUBSTRING_INDEX(SUBSTRING_INDEX(LEFT(NEW.MESSAGE, 100), ' at ', -1), ':', 1));
    END;
START TRANSACTION;

		SELECT name_employee, lastName_employee INTO p_name_employee, p_lastName_employee
		FROM tb_employee WHERE id_employee = p_id_employee;

        -- Obtener el primer nombre y el primer apellido
        SET p_name_employee = TRIM(p_name_employee);
        SET p_lastName_employee = TRIM(p_lastName_employee);
        SET p_name_employee_n = SUBSTRING_INDEX(p_name_employee, ' ', 1);
        SET p_lastName_employee_n = SUBSTRING_INDEX(p_lastName_employee, ' ', 1);

        -- Generar el nombre de usuario
        SET username = CONCAT(LOWER(p_name_employee_n), '.', LOWER(p_lastName_employee_n));

        -- Verificar si el nombre de usuario ya existe
        SELECT COUNT(*) INTO usernameExists FROM tb_user WHERE name_user = username;
    
        -- Si el nombre de usuario ya existe, agregar un número al final
        WHILE usernameExists > 0 DO
            SET counter = counter + 1;
            SET username = CONCAT(LOWER(p_name_employee_n), '.', LOWER(p_lastName_employee_n), counter);
            SELECT COUNT(*) INTO usernameExists FROM tb_user WHERE name_user = username;
        END WHILE;

        -- Inserción en la tabla tb_user
        INSERT INTO tb_user (id_userType, id_employee, name_user, password_user, state_user,  createdDate_user, lastSession_user)
        VALUES (p_id_userType, p_id_employee, username, p_password_user, TRUE, NOW(), NOW());

        COMMIT;

        SET p_success = TRUE;
        SET p_message = 'Inserción exitosa';
END $$
DELIMITER ;




DELIMITER $$
CREATE PROCEDURE pa_updateEmployee(
    IN p_employeeId INT,
    IN p_id_codeType INT,
    IN p_id_typeContract INT,
    IN p_id_departament INT,
    IN p_id_jobTitle INT,
    IN p_ci_employee VARCHAR(13),
    IN p_name_employee VARCHAR(100),
    IN p_lastName_employee VARCHAR(150),
    IN p_startDate_employee DATE,
    IN p_phoneNumber_employee VARCHAR(13),
    IN p_address_employee TEXT,
    IN p_email_employee VARCHAR(100),
    IN p_salary_employee DECIMAL(10,2),
    OUT p_success BOOLEAN,
    OUT p_message TEXT
)
BEGIN
    DECLARE cedulaExists INT DEFAULT 0;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_success = FALSE;
        SET p_message = CONCAT('Error en la transacción: ', SUBSTRING_INDEX(SUBSTRING_INDEX(LEFT(NEW.MESSAGE, 100), ' at ', -1), ':', 1));
    END;

    START TRANSACTION;

    -- Verificar si el número de cédula ya existe en otro empleado
    SELECT COUNT(*) INTO cedulaExists FROM tb_employee WHERE ci_employee = p_ci_employee AND id_employee <> p_employeeId;
    
    IF cedulaExists > 0 THEN
        SET p_success = FALSE;
        SET p_message = 'El número de cédula ya existe en otro empleado';
        ROLLBACK;
    ELSE
        -- Actualización en la tabla tb_employee
        UPDATE tb_employee
        SET
            id_codeType = p_id_codeType,
            id_typeContract = p_id_typeContract,
            id_departament = p_id_departament,
            id_jobTitle = p_id_jobTitle,
            ci_employee = p_ci_employee,
            name_employee = p_name_employee,
            lastName_employee = p_lastName_employee,
            startDate_employee = p_startDate_employee,
            phoneNumber_employee = p_phoneNumber_employee,
            address_employee = p_address_employee,
            email_employee = p_email_employee,
            salary_employee = p_salary_employee
        WHERE id_employee = p_employeeId;

        COMMIT;

        SET p_success = TRUE;
        SET p_message = 'Actualización exitosa';
    END IF;
END $$

DELIMITER ;




DELIMITER $$
CREATE PROCEDURE pa_updateEmployeeUser(
    IN p_employeeId INT,
    IN p_id_codeType INT,
    IN p_id_typeContract INT,
    IN p_id_departament INT,
    IN p_ci_employee VARCHAR(13),
    IN p_name_employee VARCHAR(100),
    IN p_lastName_employee VARCHAR(150),
    IN p_startDate_employee DATE,
    IN p_phoneNumber_employee VARCHAR(13),
    IN p_address_employee TEXT,
    IN p_email_employee VARCHAR(100),
    IN p_id_userType INT,
    IN p_password_user VARCHAR(200),
    OUT p_success BOOLEAN,
    OUT p_message TEXT
)
BEGIN
    DECLARE username VARCHAR(255);
    DECLARE counter INT DEFAULT 0;
    DECLARE usernameExists INT DEFAULT 0;
    DECLARE p_name_employee_n VARCHAR(255);
    DECLARE p_lastName_employee_n VARCHAR(255);
    DECLARE p_current_name_employee VARCHAR(100);
    DECLARE p_current_lastName_employee VARCHAR(150);
    DECLARE cedulaExists INT DEFAULT 0;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_success = FALSE;
        SET p_message = CONCAT('Error en la transacción: ', SUBSTRING_INDEX(SUBSTRING_INDEX(LEFT(NEW.MESSAGE, 100), ' at ', -1), ':', 1));
    END;

    START TRANSACTION;

    -- Obtener el primer nombre y el primer apellido
    SET p_name_employee = TRIM(p_name_employee);
    SET p_lastName_employee = TRIM(p_lastName_employee);
    SET p_name_employee_n = SUBSTRING_INDEX(p_name_employee, ' ', 1);
    SET p_lastName_employee_n = SUBSTRING_INDEX(p_lastName_employee, ' ', 1);

    -- Verificar si el nombre y apellido recibidos son diferentes a los registrados en la base de datos
    SELECT name_employee, lastName_employee INTO p_current_name_employee, p_current_lastName_employee
    FROM tb_employee
    WHERE id_employee = p_employeeId;

    IF p_current_name_employee <> p_name_employee OR p_current_lastName_employee <> p_lastName_employee THEN
        -- Generar el nombre de usuario solo si hay cambios en el nombre o apellido
        SET username = CONCAT(LOWER(p_name_employee_n), '.', LOWER(p_lastName_employee_n));

        -- Verificar si el nombre de usuario ya existe
        SELECT COUNT(*) INTO usernameExists FROM tb_user WHERE name_user = username AND id_employee = p_employeeId;
        
        IF usernameExists = 0 THEN
            -- Si el nombre de usuario ya existe, agregar un número al final
            WHILE usernameExists > 0 DO
                SET counter = counter + 1;
                SET username = CONCAT(LOWER(p_name_employee_n), '.', LOWER(p_lastName_employee_n), counter);
                SELECT COUNT(*) INTO usernameExists FROM tb_user WHERE name_user = username;
            END WHILE;
        END IF;
    ELSE
        -- Mantener el nombre de usuario existente sin cambios
        SELECT name_user INTO username FROM tb_user WHERE id_employee = p_employeeId;
    END IF;
    
    -- Verificar si el número de cédula ya existe en otro empleado
    SELECT COUNT(*) INTO cedulaExists FROM tb_employee WHERE ci_employee = p_ci_employee AND id_employee <> p_employeeId;
    
    IF cedulaExists > 0 THEN
        SET p_success = FALSE;
        SET p_message = 'El número de cédula ya existe en otro empleado';
        ROLLBACK;
    ELSE
        -- Actualización en la tabla tb_employee
        UPDATE tb_employee
        SET
            id_codeType = p_id_codeType,
            id_typeContract = p_id_typeContract,
            id_departament = p_id_departament,
            ci_employee = p_ci_employee,
            name_employee = p_name_employee,
            lastName_employee = p_lastName_employee,
            startDate_employee = p_startDate_employee,
            phoneNumber_employee = p_phoneNumber_employee,
            address_employee = p_address_employee,
            email_employee = p_email_employee
        WHERE id_employee = p_employeeId;

        -- Actualización en la tabla tb_user
        UPDATE tb_user
        SET
            id_userType = p_id_userType,
            name_user = username,
            password_user = p_password_user
        WHERE id_employee = p_employeeId;

        COMMIT;

        SET p_success = TRUE;
        SET p_message = 'Actualización exitosa';
    END IF;
END $$

DELIMITER ;


DELIMITER $$
CREATE PROCEDURE pa_disableEmployee(
    IN p_employee_id INT,
    OUT p_success BOOLEAN,
    OUT p_message TEXT
)
BEGIN
    DECLARE v_user_id INT;
    DECLARE v_exists INT;

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_success = FALSE;
        SET p_message = CONCAT('Error en la transacción: ', SUBSTRING_INDEX(SUBSTRING_INDEX(LEFT(MESSAGE, 100), ' at ', -1), ':', 1));
    END;

    START TRANSACTION;
    
    -- Verificar si hay registros de vacationPeriod para el id_employee
    SELECT COUNT(*) INTO v_exists FROM tb_vacationPeriod WHERE id_employee = p_employee_id;

    IF v_exists > 0 THEN
        -- Deshabilitar usuario
        UPDATE tb_vacationPeriod
        SET 
            earnedDays_vacationPeriod = 0,
            balanceDays_vacationPeriod = 0,
            balanceWorkingDays_vacationPeriod = 0,
            balanceWeekendDays_vacationPeriod = 0,
            state_vacationPeriod = 0
        WHERE id_employee = p_employee_id;
        
        -- Verificar si se actualizó algún registro
        IF ROW_COUNT() = 0 THEN
            SET p_success = FALSE;
            SET p_message = 'No se pudo deshabilitar el empleado';
            ROLLBACK;
        ELSE
            COMMIT;
            SET p_success = TRUE;
            SET p_message = 'Empleado deshabilitado exitosamente';
        END IF;
    ELSE
        SET p_success = FALSE;
        SET p_message = 'No se encontraron registros de periodos de vacaciones para este empleado';
        ROLLBACK;
    END IF;
    
END $$
DELIMITER ;




DELIMITER $$
CREATE PROCEDURE pa_updateUser(
    IN p_id_user INT,
    IN p_id_userType INT,
    IN p_password_user VARCHAR(200),
    OUT p_success BOOLEAN,
    OUT p_message TEXT
)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_success = FALSE;
        SET p_message = CONCAT('Error en la transacción: ', SUBSTRING_INDEX(SUBSTRING_INDEX(LEFT(NEW.MESSAGE, 100), ' at ', -1), ':', 1));
    END;
START TRANSACTION;
        -- Update a la tabla
        UPDATE tb_user 
		  SET id_userType = p_id_userType, 
		  password_user = p_password_user
        WHERE id_user = p_id_user;

        COMMIT;

        SET p_success = TRUE;
        SET p_message = 'Actualización exitosa';
END $$
DELIMITER ;



DELIMITER $$
CREATE PROCEDURE pa_disableUser(
    IN p_user_id INT,
    OUT p_success BOOLEAN,
    OUT p_message TEXT
)
BEGIN
    DECLARE v_user_id INT;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_success = FALSE;
        SET p_message = CONCAT('Error en la transacción: ', SUBSTRING_INDEX(SUBSTRING_INDEX(LEFT(MESSAGE, 100), ' at ', -1), ':', 1));
    END;

    START TRANSACTION;
    
    -- Deshabilitar usuario
    UPDATE tb_user
    SET state_user = FALSE
    WHERE id_user = p_user_id;
    
    COMMIT;
    
    SET p_success = TRUE;
    SET p_message = 'Usuario deshabilitado exitosamente';
END $$
DELIMITER ;


DELIMITER $$
CREATE PROCEDURE pa_enableUser(
    IN p_user_id INT,
    OUT p_success BOOLEAN,
    OUT p_message TEXT
)
BEGIN
    DECLARE v_user_id INT;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_success = FALSE;
        SET p_message = CONCAT('Error en la transacción: ', SUBSTRING_INDEX(SUBSTRING_INDEX(LEFT(MESSAGE, 100), ' at ', -1), ':', 1));
    END;

    START TRANSACTION;
    
    -- Habilitar usuario
    UPDATE tb_user
    SET state_user = TRUE
    WHERE id_user = p_user_id;
    
    COMMIT;
    
    SET p_success = TRUE;
    SET p_message = 'Usuario habilitado exitosamente';
END $$

DELIMITER ;



DELIMITER $$
CREATE PROCEDURE pa_validateUser(
    IN p_username VARCHAR(100),
    OUT p_success BOOLEAN,
    OUT p_message TEXT,
    OUT p_employee_id INT,
    OUT p_user_id INT,
    OUT p_password_user VARCHAR(200)
)
BEGIN
    DECLARE v_state_user BOOLEAN;
    
    -- Verificar si el usuario existe en la base de datos
    SELECT id_employee, id_user, state_user, password_user INTO p_employee_id, p_user_id, v_state_user, p_password_user
    FROM tb_user
    WHERE name_user = p_username;

    IF p_user_id IS NOT NULL THEN
        IF v_state_user THEN
            SET p_success = TRUE;
            SET p_message = 'El usuario existe en la base de datos y tiene acceso.';
        ELSE
            SET p_success = FALSE;
            SET p_message = 'El usuario existe en la base de datos pero no tiene acceso.';
        END IF;
    ELSE
        SET p_success = FALSE;
        SET p_message = 'El usuario no existe en la base de datos.';
    END IF;
END $$
DELIMITER ;


DELIMITER $$
CREATE PROCEDURE pa_getPasswordUser(
    IN p_id_user INT,
    OUT p_password_user VARCHAR(200),
    OUT p_success BOOLEAN
)
BEGIN
    DECLARE v_user_count INT;

    -- Verificar si el usuario existe en la base de datos
    SELECT COUNT(*) INTO v_user_count
    FROM tb_user
    WHERE id_user = p_id_user;

    IF v_user_count > 0 THEN
        -- Obtener la contraseña del usuario
        SELECT password_user INTO p_password_user
        FROM tb_user
        WHERE id_user = p_id_user;

        SET p_success = TRUE;
    ELSE
        SET p_success = FALSE;
    END IF;
END $$
DELIMITER ;


DELIMITER $$
CREATE PROCEDURE pa_updatePasswordUser(
    IN p_id_user INT,
    IN p_new_password VARCHAR(200),
    OUT p_success BOOLEAN,
    OUT p_message TEXT
)
BEGIN
    DECLARE v_user_count INT;

    -- Iniciar la transacción
    START TRANSACTION;

    -- Verificar si el usuario existe en la base de datos
    SELECT COUNT(*) INTO v_user_count
    FROM tb_user
    WHERE id_user = p_id_user;

    IF v_user_count > 0 THEN
        -- Actualizar la contraseña del usuario dentro de la transacción
        BEGIN
            UPDATE tb_user
            SET password_user = p_new_password
            WHERE id_user = p_id_user;

            -- Marcar la transacción como exitosa
            SET p_success = TRUE;
            SET p_message = 'La contraseña del usuario ha sido actualizada correctamente.';
        END;
    ELSE
        -- Marcar la transacción como fallida
        SET p_success = FALSE;
        SET p_message = 'No se encontró un usuario con el ID especificado.';
    END IF;

    -- Confirmar o revertir la transacción
    IF p_success THEN
        COMMIT;
    ELSE
        ROLLBACK;
    END IF;
END $$
DELIMITER ;



DELIMITER $$
CREATE PROCEDURE pa_updateLastSession(
    IN p_id_user INT
)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
    END;

    START TRANSACTION;

    UPDATE tb_user
    SET lastSession_user = CURRENT_TIMESTAMP
    WHERE id_user = p_id_user;

    IF ROW_COUNT() > 0 THEN
        COMMIT;
    ELSE
        ROLLBACK;
    END IF;

END $$

DELIMITER ;


DELIMITER $$
CREATE PROCEDURE pa_getEmployeeDataByID(
    IN p_employee_id INT
)
BEGIN
    -- Obtener los datos del empleado basado en el ID de empleado
    SELECT *
    FROM tb_employee
    WHERE id_employee = p_employee_id;
END $$
DELIMITER ;


DELIMITER $$
CREATE PROCEDURE pa_getUserDataByID(
    IN p_user_id INT
)
BEGIN
    -- Obtener los datos del usuario basado en el ID de empleado
    SELECT *
    FROM tb_user
    WHERE id_user = p_user_id;
END $$
DELIMITER ;




DELIMITER $$
CREATE PROCEDURE pa_resetPasswordUser(
    IN p_user_id INT,
    IN p_new_password VARCHAR(200),
    OUT p_success BOOLEAN,
    OUT p_message TEXT
)
BEGIN
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_success = FALSE;
        SET p_message = CONCAT('Error en la transacción: ', SUBSTRING_INDEX(SUBSTRING_INDEX(LEFT(MESSAGE, 100), ' at ', -1), ':', 1));
    END;
    
    START TRANSACTION;
    
    -- Verificar si el usuario existe
    IF p_user_id IS NOT NULL THEN
        -- Actualizar la contraseña del usuario
        UPDATE tb_user
        SET password_user = p_new_password
        WHERE id_user = p_user_id;
        
        COMMIT;
        
        SET p_success = TRUE;
        SET p_message = 'Contraseña restablecida exitosamente.';
    ELSE
        SET p_success = FALSE;
        SET p_message = 'No se encontró un usuario.';
    END IF;
END $$

DELIMITER ;



-- -----------------------------------------------------------------------------------------------------

DELIMITER $$
CREATE PROCEDURE pa_manageDepartament(
    IN p_id_departament INT,
    IN p_name_departament TEXT,
    IN p_operation VARCHAR(10),
    OUT p_success BOOLEAN,
    OUT p_message TEXT
)
BEGIN
    DECLARE num_occurrences_dept INT;
    DECLARE num_occurrences_emp INT;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_success = FALSE;
        SET p_message = CONCAT('Error en la transacción: ', SUBSTRING_INDEX(SUBSTRING_INDEX(LEFT(NEW.MESSAGE, 100), ' at ', -1), ':', 1));
    END;

    START TRANSACTION;

    IF p_operation = 'INSERT' THEN
        IF p_name_departament IS NULL OR p_name_departament = '' THEN
            SET p_success = FALSE;
            SET p_message = 'Se requiere proporcionar el nombre del departamento para la operación de inserción';
        ELSE
            INSERT INTO tb_departament (name_departament)
            VALUES (p_name_departament);

            SET p_success = TRUE;
            SET p_message = 'Inserción exitosa';
        END IF;

    ELSEIF p_operation = 'UPDATE' THEN
        IF p_id_departament IS NULL THEN
            SET p_success = FALSE;
            SET p_message = 'Se requiere proporcionar el ID del departamento para la operación de actualización';
        ELSEIF p_name_departament IS NULL OR p_name_departament = '' THEN
            SET p_success = FALSE;
            SET p_message = 'Se requiere proporcionar el nombre del departamento para la operación de actualización';
        ELSE
            UPDATE tb_departament
            SET name_departament = p_name_departament
            WHERE id_departament = p_id_departament;

            SET p_success = TRUE;
            SET p_message = 'Actualización exitosa';
        END IF;

    ELSEIF p_operation = 'DELETE' THEN
        IF p_id_departament IS NULL THEN
            SET p_success = FALSE;
            SET p_message = 'Se requiere proporcionar el ID del departamento para la operación de eliminación';
        ELSE
            -- Validar si el ID está presente en la tabla tb_departament
            SET num_occurrences_dept = (SELECT COUNT(*) FROM tb_departament WHERE id_departament = p_id_departament);
            
            IF num_occurrences_dept = 0 THEN
                SET p_success = FALSE;
                SET p_message = 'El departamento con el ID proporcionado no existe en la tabla tb_departament';
            ELSE
                -- Validar si el ID está presente en la tabla tb_employee
                SET num_occurrences_emp = (SELECT COUNT(*) FROM tb_employee WHERE id_departament = p_id_departament);
                
                IF num_occurrences_emp > 0 THEN
                    SET p_success = FALSE;
                    SET p_message = 'No se puede eliminar el departamento porque está siendo utilizado en la tabla tb_employee';
                ELSE
                    DELETE FROM tb_departament
                    WHERE id_departament = p_id_departament;

                    SET p_success = TRUE;
                    SET p_message = 'Eliminación exitosa';
                END IF;
            END IF;
        END IF;

    ELSE
        SET p_success = FALSE;
        SET p_message = 'Operación no válida';

    END IF;

    COMMIT;
    
END $$
DELIMITER ;


-- -----------------------------------------------------------------------------------------

DELIMITER $$
CREATE PROCEDURE pa_manageTypeContract(
    IN p_id_typeContract INT,
    IN p_name_typeContract TEXT,
    IN p_operation ENUM('INSERT', 'UPDATE', 'DELETE'),
    OUT p_success BOOLEAN,
    OUT p_message TEXT
)
BEGIN
    DECLARE num_occurrences_contract INT;
    DECLARE num_occurrences_emp INT;
    
    -- Manejo de excepciones
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_success = FALSE;
        GET DIAGNOSTICS CONDITION 1 @sqlstate = RETURNED_SQLSTATE, @errmsg = MESSAGE_TEXT;
        SET p_message = CONCAT('Error en la transacción: ', @errmsg);
    END;

    START TRANSACTION;

    IF p_operation = 'INSERT' THEN
        IF p_name_typeContract IS NULL OR p_name_typeContract = '' THEN
            SET p_success = FALSE;
            SET p_message = 'Se requiere proporcionar el nombre del tipo de contrato para la operación de inserción';
            ROLLBACK;
        ELSE
            INSERT INTO tb_typeContract (name_typeContract)
            VALUES (p_name_typeContract);

            SET p_success = TRUE;
            SET p_message = 'Inserción exitosa';
            COMMIT;
        END IF;

    ELSEIF p_operation = 'UPDATE' THEN
        IF p_id_typeContract IS NULL THEN
            SET p_success = FALSE;
            SET p_message = 'Se requiere proporcionar el ID del tipo de contrato para la operación de actualización';
            ROLLBACK;
        ELSEIF p_name_typeContract IS NULL OR p_name_typeContract = '' THEN
            SET p_success = FALSE;
            SET p_message = 'Se requiere proporcionar el nombre del tipo de contrato para la operación de actualización';
            ROLLBACK;
        ELSE
            UPDATE tb_typeContract
            SET name_typeContract = p_name_typeContract
            WHERE id_typeContract = p_id_typeContract;

            SET p_success = TRUE;
            SET p_message = 'Actualización exitosa';
            COMMIT;
        END IF;

    ELSEIF p_operation = 'DELETE' THEN
        IF p_id_typeContract IS NULL THEN
            SET p_success = FALSE;
            SET p_message = 'Se requiere proporcionar el ID del tipo de contrato para la operación de eliminación';
            ROLLBACK;
        ELSE
            SET num_occurrences_contract = (SELECT COUNT(*) FROM tb_typeContract WHERE id_typeContract = p_id_typeContract);
            
            IF num_occurrences_contract = 0 THEN
                SET p_success = FALSE;
                SET p_message = 'El tipo de contrato con el ID proporcionado no existe en la tabla tb_typeContract';
                ROLLBACK;
            ELSE
                SET num_occurrences_emp = (SELECT COUNT(*) FROM tb_employee WHERE id_typeContract = p_id_typeContract);
                
                IF num_occurrences_emp > 0 THEN
                    SET p_success = FALSE;
                    SET p_message = 'No se puede eliminar el tipo de contrato porque está siendo utilizado en la tabla tb_employee';
                    ROLLBACK;
                ELSE
                    DELETE FROM tb_typeContract
                    WHERE id_typeContract = p_id_typeContract;

                    SET p_success = TRUE;
                    SET p_message = 'Eliminación exitosa';
                    COMMIT;
                END IF;
            END IF;
        END IF;

    ELSE
        SET p_success = FALSE;
        SET p_message = 'Operación no válida';
        ROLLBACK;

    END IF;

END $$

DELIMITER ;


-- -------------------------------------------------------------------------------------------------------------------------

DELIMITER $$
CREATE PROCEDURE pa_manageReason(
    IN p_id_reason INT,
    IN p_name_reason TEXT,
    IN p_operation VARCHAR(10),
    OUT p_success BOOLEAN,
    OUT p_message TEXT
)
BEGIN
    DECLARE num_occurrences_reason INT;
    DECLARE num_occurrences_perm INT;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_success = FALSE;
        SET p_message = CONCAT('Error en la transacción: ', SUBSTRING_INDEX(SUBSTRING_INDEX(LEFT(NEW.MESSAGE, 100), ' at ', -1), ':', 1));
    END;

    START TRANSACTION;

    IF p_operation = 'INSERT' THEN
        IF p_name_reason IS NULL OR p_name_reason = '' THEN
            SET p_success = FALSE;
            SET p_message = 'Se requiere proporcionar el nombre de la razón para la operación de inserción';
        ELSE
            INSERT INTO tb_reason (name_reason)
            VALUES (p_name_reason);

            SET p_success = TRUE;
            SET p_message = 'Inserción exitosa';
        END IF;

    ELSEIF p_operation = 'UPDATE' THEN
        IF p_id_reason IS NULL THEN
            SET p_success = FALSE;
            SET p_message = 'Se requiere proporcionar el ID de la razón para la operación de actualización';
        ELSEIF p_name_reason IS NULL OR p_name_reason = '' THEN
            SET p_success = FALSE;
            SET p_message = 'Se requiere proporcionar el nombre de la razón para la operación de actualización';
        ELSE
            UPDATE tb_reason
            SET name_reason = p_name_reason
            WHERE id_reason = p_id_reason;

            SET p_success = TRUE;
            SET p_message = 'Actualización exitosa';
        END IF;

    ELSEIF p_operation = 'DELETE' THEN
        IF p_id_reason IS NULL THEN
            SET p_success = FALSE;
            SET p_message = 'Se requiere proporcionar el ID de la razón para la operación de eliminación';
        ELSE
            -- Validar si el ID está presente en la tabla tb_reason
            SET num_occurrences_reason = (SELECT COUNT(*) FROM tb_reason WHERE id_reason = p_id_reason);
            
            IF num_occurrences_reason = 0 THEN
                SET p_success = FALSE;
                SET p_message = 'La razón con el ID proporcionado no existe en la tabla tb_reason';
            ELSE
                -- Validar si el ID está presente en la tabla tb_permission
                SET num_occurrences_perm = (SELECT COUNT(*) FROM tb_permission WHERE id_reason = p_id_reason);
                
                IF num_occurrences_perm > 0 THEN
                    SET p_success = FALSE;
                    SET p_message = 'No se puede eliminar la razón porque está siendo utilizada en la tabla tb_permission';
                ELSE
                    DELETE FROM tb_reason
                    WHERE id_reason = p_id_reason;

                    SET p_success = TRUE;
                    SET p_message = 'Eliminación exitosa';
                END IF;
            END IF;
        END IF;

    ELSE
        SET p_success = FALSE;
        SET p_message = 'Operación no válida';

    END IF;

    COMMIT;

END $$

DELIMITER ;


-- ----------------------------------------------------------------------------------
DELIMITER $$
CREATE PROCEDURE pa_manageJobTitle(
    IN p_id_jobTitle INT,
    IN p_name_jobTitle TEXT,
    IN p_operation VARCHAR(10),
    OUT p_success BOOLEAN,
    OUT p_message TEXT
)
BEGIN
    DECLARE num_occurrences_job INT;
    DECLARE num_occurrences_emp INT;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_success = FALSE;
        SET p_message = CONCAT('Error en la transacción: ', SUBSTRING_INDEX(SUBSTRING_INDEX(LEFT(NEW.MESSAGE, 100), ' at ', -1), ':', 1));
    END;

    START TRANSACTION;

    IF p_operation = 'INSERT' THEN
        IF p_name_jobTitle IS NULL OR p_name_jobTitle = '' THEN
            SET p_success = FALSE;
            SET p_message = 'Se requiere proporcionar el nombre del título del trabajo para la operación de inserción';
        ELSE
            INSERT INTO tb_jobTitle (name_jobTitle)
            VALUES (p_name_jobTitle);

            SET p_success = TRUE;
            SET p_message = 'Inserción exitosa';
        END IF;

    ELSEIF p_operation = 'UPDATE' THEN
        IF p_id_jobTitle IS NULL THEN
            SET p_success = FALSE;
            SET p_message = 'Se requiere proporcionar el ID del título del trabajo para la operación de actualización';
        ELSEIF p_name_jobTitle IS NULL OR p_name_jobTitle = '' THEN
            SET p_success = FALSE;
            SET p_message = 'Se requiere proporcionar el nombre del título del trabajo para la operación de actualización';
        ELSE
            UPDATE tb_jobTitle
            SET name_jobTitle = p_name_jobTitle
            WHERE id_jobTitle = p_id_jobTitle;

            SET p_success = TRUE;
            SET p_message = 'Actualización exitosa';
        END IF;

    ELSEIF p_operation = 'DELETE' THEN
        IF p_id_jobTitle IS NULL THEN
            SET p_success = FALSE;
            SET p_message = 'Se requiere proporcionar el ID del título del trabajo para la operación de eliminación';
        ELSE
            -- Validar si el ID está presente en la tabla tb_jobTitle
            SET num_occurrences_job = (SELECT COUNT(*) FROM tb_jobTitle WHERE id_jobTitle = p_id_jobTitle);
            
            IF num_occurrences_job = 0 THEN
                SET p_success = FALSE;
                SET p_message = 'El título del trabajo con el ID proporcionado no existe en la tabla tb_jobTitle';
            ELSE
                -- Validar si el ID está presente en la tabla tb_employee
                SET num_occurrences_emp = (SELECT COUNT(*) FROM tb_employee WHERE id_jobTitle = p_id_jobTitle);
                
                IF num_occurrences_emp > 0 THEN
                    SET p_success = FALSE;
                    SET p_message = 'No se puede eliminar el título del trabajo porque está siendo utilizado en la tabla tb_employee';
                ELSE
                    DELETE FROM tb_jobTitle
                    WHERE id_jobTitle = p_id_jobTitle;

                    SET p_success = TRUE;
                    SET p_message = 'Eliminación exitosa';
                END IF;
            END IF;
        END IF;

    ELSE
        SET p_success = FALSE;
        SET p_message = 'Operación no válida';

    END IF;

    COMMIT;
    
END $$
DELIMITER ;


-- ------------------------------------------------------------------------------------

CREATE EVENT AssignVacationDaysEvent
    ON SCHEDULE EVERY 1 DAY -- Se ejecuta cada dia
    DO CALL pa_assignVacationDays();


DELIMITER $$

CREATE PROCEDURE pa_assignVacationDays()
BEGIN
    DECLARE done INT DEFAULT 0;
    DECLARE _id_employee INT;
    DECLARE _start_date DATE;
    DECLARE _start_date_origin DATE;
    DECLARE _end_date DATE;
    DECLARE _earned_days_vacation INT;
    DECLARE _balance_working_days INT;
    DECLARE _id_codeType INT;
    DECLARE _years_of_service INT;
    DECLARE _earned_days INT;
    DECLARE _balance_days DECIMAL(10,2);
    DECLARE _working_days INT;
    DECLARE _weekend_days INT;
    DECLARE _balance_periods DECIMAL(10,2);
    DECLARE _id_vacationPeriod INT;
    DECLARE _count_periods INT;
    DECLARE cur CURSOR FOR
	SELECT 
	    e.id_employee,
	    vp.startDate_vacationPeriod,
	    vp.endDate_vacationPeriod,
	    vp.earnedDays_vacationPeriod,
	    vp.balanceWorkingDays_vacationPeriod,
	    e.id_codeType
	FROM
	    tb_employee e
	INNER JOIN 
	    tb_vacationPeriod vp ON e.id_employee = vp.id_employee
	INNER JOIN
	    (SELECT id_employee, MAX(startDate_vacationPeriod) as MaxStartDate
	     FROM tb_vacationPeriod
	     WHERE state_vacationPeriod = 1
	     GROUP BY id_employee) subq ON e.id_employee = subq.id_employee AND vp.startDate_vacationPeriod = subq.MaxStartDate
	WHERE
	    vp.state_vacationPeriod = 1 AND DATEDIFF(CURDATE(), vp.endDate_vacationPeriod) >= 365; -- Periodo activo y busca al finalizar un año;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

    OPEN cur;

    read_loop: LOOP
        FETCH cur INTO _id_employee, _start_date, _end_date, _earned_days_vacation, _balance_working_days, _id_codeType;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- Obtener fecha de inicio laboral
        SET _start_date_origin = (SELECT startDate_employee FROM tb_employee WHERE id_employee = _id_employee);
        
        -- Cacula tiempo tatal que lleva trabajando, en base al tiempo de inicio laboral, con el tiempo actual     
        SET _years_of_service = TIMESTAMPDIFF(YEAR, _start_date_origin, DATE_ADD(CURDATE(), INTERVAL 1 DAY));
        
        -- Suma de los saldso de los periodos
   	  SET _balance_periods = (SELECT SUM(balanceDays_vacationPeriod) FROM tb_vacationPeriod
		  WHERE id_employee = _id_employee AND state_vacationPeriod = 1);
		  
        -- Condicionales LOSEP
        IF _id_codeType = 1 THEN
        		SET _earned_days = 30;
        		SET _working_days = 22;
        		SET _weekend_days = 8;
        		
				-- Desactivación de periodo más antiguo
				IF (_balance_periods + _earned_days) > 60 THEN
					-- Captura el id, del periodo más antiguo, activo
					SET _id_vacationPeriod = (SELECT id_vacationPeriod FROM tb_vacationPeriod
					WHERE id_employee = _id_employee AND state_vacationPeriod = 1
					ORDER BY startDate_vacationPeriod ASC LIMIT 1);
					-- Desactiva el periodo más antiguo
					UPDATE tb_vacationPeriod 
        			SET state_vacationPeriod = 0 WHERE id_vacationPeriod = _id_vacationPeriod;
        		END IF;
        		
        		-- Creación de nuevo periodo
				INSERT INTO tb_vacationPeriod 
				(id_employee, 
				startDate_vacationPeriod, 
				endDate_vacationPeriod, 
				earnedDays_vacationPeriod, 
				balanceDays_vacationPeriod, 
				balanceWorkingDays_vacationPeriod,
				balanceWeekendDays_vacationPeriod,
				state_vacationPeriod)		
				VALUES 
				(_id_employee, 
				DATE_ADD(_end_date, INTERVAL 1 DAY), 
				DATE_ADD(DATE_ADD(_end_date, INTERVAL 1 YEAR),INTERVAL -1 DAY),
				_earned_days, 
				_earned_days, 
				_working_days,
				_weekend_days,
				1);
				
        -- Condicionales código de trabajo
        ELSEIF _id_codeType = 2 THEN
			    -- Asignación de dias de acuerdo al año
			    IF _years_of_service >= 5 AND _years_of_service < 20 THEN
			        SET _earned_days = _earned_days_vacation + 1;
			        SET _working_days = _balance_working_days + 1;
			        SET _weekend_days = 4;
			    ELSEIF _years_of_service >= 20 THEN
			        SET _earned_days = 30;
			        SET _working_days = 26;
			        SET _weekend_days = 4;
			    ELSE
			        SET _earned_days = 15;
			        SET _working_days = 11;
			        SET _weekend_days = 4;
			    END IF;
			    
			    -- Cantidad de periodos activos
			    SET _count_periods = (SELECT COUNT(*) FROM tb_vacationperiod 
				 WHERE id_employee = _id_employee AND state_vacationPeriod = 1);
        		
				-- Desactivación de periodo más antiguo
				IF (_count_periods + 1) > 3 THEN
					-- Captura el id, del periodo más antiguo, activo
					SET _id_vacationPeriod = (SELECT id_vacationPeriod FROM tb_vacationPeriod
					WHERE id_employee = _id_employee AND state_vacationPeriod = 1
					ORDER BY startDate_vacationPeriod ASC LIMIT 1);
					-- Desactiva el periodo más antiguo
					UPDATE tb_vacationPeriod 
        			SET state_vacationPeriod = 0 WHERE id_vacationPeriod = _id_vacationPeriod; 
				END IF;
				-- Creación de nuevo periodo
				INSERT INTO tb_vacationPeriod 
				(id_employee, 
				startDate_vacationPeriod, 
				endDate_vacationPeriod, 
				earnedDays_vacationPeriod, 
				balanceDays_vacationPeriod, 
				balanceWorkingDays_vacationPeriod,
				balanceWeekendDays_vacationPeriod,
				state_vacationPeriod)		
				VALUES 
				(_id_employee, 
				DATE_ADD(_end_date, INTERVAL 1 DAY), 
				DATE_ADD(DATE_ADD(_end_date, INTERVAL 1 YEAR),INTERVAL -1 DAY),
				_earned_days, 
				_earned_days, 
				_working_days,
				_weekend_days,
				1);
        		
        END IF;
    END LOOP;

    CLOSE cur;
END$$

DELIMITER ;


-- ---------------------------------------------------------------------------
DELIMITER $$

CREATE EVENT resetNumberPeriod
ON SCHEDULE EVERY 1 YEAR STARTS CONCAT(YEAR(NOW()), '-01-01 00:00:00')
DO CALL pa_resetNumberPeriod() $$

DELIMITER ;




DELIMITER $$

CREATE PROCEDURE pa_resetNumberPeriod()
BEGIN
    DECLARE thisYear YEAR;
    DECLARE existingId INT;

    -- Obtener el año actual
    SET thisYear = YEAR(CURDATE());

    -- Verificar si ya existe un registro para este año
    SELECT id_numberPeriod INTO existingId
    FROM tb_numberPeriod
    WHERE year_numberPeriod = thisYear
    LIMIT 1;

    -- Si no existe un registro para este año
    IF existingId IS NULL THEN
        -- Deshabilitar todos los registros anteriores
        UPDATE tb_numberPeriod
        SET state_numberPeriod = FALSE
        WHERE year_numberPeriod < thisYear;

        -- Crear un nuevo registro para este año
        INSERT INTO tb_numberPeriod (year_numberPeriod, count_numberPeriod, state_numberPeriod)
        VALUES (thisYear, 0, TRUE);
    END IF;
END $$

DELIMITER ;


-- --------------------------------------------------------------------------------------------------

DELIMITER $$

CREATE PROCEDURE pa_insertVacationPeriods(
  IN p_id_employee INT,
  OUT p_message VARCHAR(255),
  OUT p_success BOOLEAN
)
BEGIN
  DECLARE v_yearCount INT DEFAULT 0;
  DECLARE v_startDate DATE;
  DECLARE v_startDate_while DATE;
  DECLARE v_endDate_while DATE;
  DECLARE v_exists INT;
  DECLARE v_lastID INT;
  DECLARE v_id_codeType INT;
  DECLARE v_maxYearCount INT;
  DECLARE v_earnedDays INT;
  DECLARE v_balanceDays INT;
  DECLARE v_workingDays INT;
  DECLARE v_employeeEligible BOOLEAN DEFAULT TRUE;
  
  SET v_earnedDays = 15;
  SET v_balanceDays = 15;
  SET v_workingDays = 11;

  -- Iniciar la transacción
  START TRANSACTION;

  -- Obtener la fecha de inicio del empleado
  SELECT startDate_employee INTO v_startDate FROM tb_employee WHERE id_employee = p_id_employee;

  -- Establecer el número de años que han pasado desde la fecha de inicio hasta un año antes de la fecha actual
  SET v_maxYearCount = TIMESTAMPDIFF(YEAR, v_startDate, CURDATE()) - 1;

  -- Verificar si el empleado tiene menos de un año de inicio laboral
  IF v_maxYearCount < 0 THEN
    SET v_employeeEligible = FALSE;
  END IF;

  IF v_employeeEligible THEN
    -- Verificar si ya existen periodos de vacaciones para el empleado
    SELECT COUNT(*) INTO v_exists FROM tb_vacationPeriod WHERE id_employee = p_id_employee;

    IF v_exists = 0 THEN
      -- Insertar un período de vacaciones para cada año desde la fecha de inicio hasta un año antes de la fecha actual
      WHILE v_yearCount <= v_maxYearCount DO
        -- Establecer las fechas de inicio y fin para el período de vacaciones
        SET v_startDate_while = DATE_ADD(v_startDate, INTERVAL v_yearCount YEAR);
        SET v_endDate_while = DATE_SUB(DATE_ADD(v_startDate, INTERVAL (v_yearCount + 1) YEAR), INTERVAL 1 DAY);

        -- Establecer los días acumulados y laborables para el id_codeType 2 a partir del sexto año
        IF v_yearCount >= 5 AND v_yearCount < 20 THEN
          SET v_earnedDays = v_earnedDays + 1;
          SET v_balanceDays = v_balanceDays + 1;
          SET v_workingDays = v_workingDays + 1;
        ELSEIF v_yearCount >= 20 THEN
          SET v_earnedDays = 30;
          SET v_balanceDays = 30;
          SET v_workingDays = 26;
        END IF;

        -- Insertar el período de vacaciones
        INSERT INTO tb_vacationPeriod (
          id_employee,
          startDate_vacationPeriod,
          endDate_vacationPeriod,
          earnedDays_vacationPeriod,
          balanceDays_vacationPeriod,
          balanceWorkingDays_vacationPeriod,
          balanceWeekendDays_vacationPeriod,
          state_vacationPeriod
        )
        VALUES (
          p_id_employee,
          v_startDate_while,
          v_endDate_while,
           0,
          0,
          0,
          0,
          FALSE
        );

        -- Guardar el último id insertado
        SET v_lastID = LAST_INSERT_ID();

        -- Incrementar el contador de años
        SET v_yearCount = v_yearCount + 1;
      END WHILE;

      -- Actualizar el último periodo de vacaciones con los valores especificados dependiendo del id_codeType
      SELECT id_codeType INTO v_id_codeType FROM tb_employee WHERE id_employee = p_id_employee;

      IF v_id_codeType = 1 THEN
        UPDATE tb_vacationPeriod 
        SET 
          earnedDays_vacationPeriod = 30,
          balanceDays_vacationPeriod = 30,
          balanceWorkingDays_vacationPeriod = 22,
          balanceWeekendDays_vacationPeriod = 8,
          state_vacationPeriod = TRUE
        WHERE 
          id_vacationPeriod = v_lastID;
      ELSEIF v_id_codeType = 2 THEN
        UPDATE tb_vacationPeriod 
        SET 
          earnedDays_vacationPeriod = v_earnedDays,
          balanceDays_vacationPeriod = v_balanceDays,
          balanceWorkingDays_vacationPeriod = v_workingDays,
          balanceWeekendDays_vacationPeriod = 4,
          state_vacationPeriod = TRUE
        WHERE 
          id_vacationPeriod = v_lastID;
      END IF;

      -- Commit de la transacción
      COMMIT;
      SET p_success = TRUE;
      SET p_message = "Períodos de vacaciones insertados correctamente";
    ELSE
      -- Rollback de la transacción
      ROLLBACK;
      SET p_success = FALSE;
      SET p_message = "Los periodos de vacaciones ya existen para el empleado.";
    END IF;
  ELSE
    -- Rollback de la transacción
    ROLLBACK;
    SET p_success = FALSE;
    SET p_message = "El empleado aún no cumple un año laboral.";
  END IF;
END $$

DELIMITER ;


DELIMITER $$

CREATE PROCEDURE pa_nextVacationPeriod(
  IN p_id_employee INT,
  OUT p_message VARCHAR(255),
  OUT p_success BOOLEAN
)
BEGIN
  DECLARE v_yearCount INT;
  DECLARE v_startDate DATE;
  DECLARE v_startDate_currentYear DATE;
  DECLARE v_endDate_currentYear DATE;
  DECLARE v_exists INT;
  DECLARE v_codeType INT;
  DECLARE v_earnedDays INT;
  DECLARE v_balanceDays INT;
  DECLARE v_workingDays INT;
  DECLARE v_weekendDays INT;
  
  -- Obtener la fecha de inicio del empleado y el codeType
  SELECT startDate_employee, id_codeType INTO v_startDate, v_codeType FROM tb_employee WHERE id_employee = p_id_employee;

  -- Obtener el año actual
  SET v_yearCount = YEAR(CURDATE()) - YEAR(v_startDate);

  -- Establecer las fechas de inicio y fin para el período de vacaciones del año actual
  SET v_startDate_currentYear = DATE_ADD(v_startDate, INTERVAL v_yearCount YEAR);
  SET v_endDate_currentYear = DATE_SUB(DATE_ADD(v_startDate, INTERVAL (v_yearCount + 1) YEAR), INTERVAL 1 DAY);

  -- Verificar si ya existe un período de vacaciones para el año actual
  SELECT COUNT(*) INTO v_exists
  FROM tb_vacationPeriod
  WHERE id_employee = p_id_employee
    AND startDate_vacationPeriod = v_startDate_currentYear
    AND endDate_vacationPeriod = v_endDate_currentYear;

  IF v_exists = 0 THEN
    -- Verificar si existen períodos de vacaciones anteriores al año actual
    SELECT COUNT(*) INTO v_exists
    FROM tb_vacationPeriod
    WHERE id_employee = p_id_employee
      AND startDate_vacationPeriod < v_startDate_currentYear;

    IF v_exists > 0 THEN
      SET p_success = FALSE;
      SET p_message = "Ya existen períodos de vacaciones anteriores al año actual";
    ELSE
      -- Establecer los valores de días según el codeType
      IF v_codeType = 1 THEN
        SET v_earnedDays = 30;
        SET v_balanceDays = 30;
        SET v_workingDays = 22;
        SET v_weekendDays = 8;
      ELSEIF v_codeType = 2 THEN
        SET v_earnedDays = 15;
        SET v_balanceDays = 15;
        SET v_workingDays = 11;
        SET v_weekendDays = 4;
      END IF;

      -- Insertar el período de vacaciones para el año actual
      INSERT INTO tb_vacationPeriod (
        id_employee,
        startDate_vacationPeriod,
        endDate_vacationPeriod,
        earnedDays_vacationPeriod,
        balanceDays_vacationPeriod,
        balanceWorkingDays_vacationPeriod,
        balanceWeekendDays_vacationPeriod,
        state_vacationPeriod
      )
      VALUES (
        p_id_employee,
        v_startDate_currentYear,
        v_endDate_currentYear,
        v_earnedDays,
        v_balanceDays,
        v_workingDays,
        v_weekendDays,
        TRUE
      );

      SET p_success = TRUE;
      SET p_message = "Período de vacaciones creado correctamente para el año actual";
    END IF;
  ELSE
    SET p_success = FALSE;
    SET p_message = "Ya existe un período de vacaciones para el año actual";
  END IF;
END $$
DELIMITER ;


DELIMITER $$

CREATE PROCEDURE pa_updateVacationPeriod(
  IN p_id_vacationPeriod INT,
  IN p_startDate_vacationPeriod DATE,
  IN p_endDate_vacationPeriod DATE,
  IN p_earnedDays_vacationPeriod DECIMAL(10, 2),
  IN p_balanceDays_vacationPeriod DECIMAL(10, 2),
  IN p_balanceWorkingDays_vacationPeriod DECIMAL(10, 2),
  IN p_balanceWeekendDays_vacationPeriod DECIMAL(10, 2),
  IN p_state_vacationPeriod BOOL,
  OUT p_message VARCHAR(255),
  OUT p_success BOOL
)
BEGIN
  DECLARE error_message TEXT DEFAULT NULL;
  DECLARE error_code INT DEFAULT NULL;

  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
  BEGIN
    GET DIAGNOSTICS CONDITION 1
      error_code = MYSQL_ERRNO,
      error_message = MESSAGE_TEXT;
  END;

  START TRANSACTION;

  UPDATE tb_vacationPeriod
  SET
    startDate_vacationPeriod = p_startDate_vacationPeriod,
    endDate_vacationPeriod = p_endDate_vacationPeriod,
    earnedDays_vacationPeriod = p_earnedDays_vacationPeriod,
    balanceDays_vacationPeriod = p_balanceDays_vacationPeriod,
    balanceWorkingDays_vacationPeriod = p_balanceWorkingDays_vacationPeriod,
    balanceWeekendDays_vacationPeriod = p_balanceWeekendDays_vacationPeriod,
    state_vacationPeriod = p_state_vacationPeriod
  WHERE id_vacationPeriod = p_id_vacationPeriod;

  IF error_message IS NOT NULL THEN
    ROLLBACK;
    SET p_message = error_message;
    SET p_success = FALSE;
  ELSE
    IF ROW_COUNT() > 0 THEN
      COMMIT;
      SET p_message = 'Datos actualizados correctamente';
      SET p_success = TRUE;
    ELSE
      ROLLBACK;
      SET p_message = 'No se encontró ningún registro con el ID proporcionado';
      SET p_success = FALSE;
    END IF;
  END IF;
END $$

DELIMITER ;




-- ------------------------------------------------------------------------------------------



DELIMITER $$

CREATE PROCEDURE pa_insertPermissionEmployee(
  IN p_id_employee INT,
  IN p_id_reason INT,
  IN p_startDate DATETIME,
  IN p_endDate DATETIME,
  IN p_observation_permission VARCHAR(255),
  OUT message VARCHAR(255),
  OUT success BOOLEAN
)
BEGIN
  DECLARE v_id_numberPeriod INT DEFAULT 1;
  DECLARE v_workingDays DECIMAL(10,2) DEFAULT 0;
  DECLARE v_weekendDays DECIMAL(10,2) DEFAULT 0;
  DECLARE v_tempDate DATE;
  DECLARE v_balanceDays DECIMAL(10,2); 
  DECLARE v_balanceWorkingDays DECIMAL(10,2);
  DECLARE v_balanceWeekendDays DECIMAL(10,2);
  DECLARE v_id_vacationPeriod INT;
  DECLARE v_vacationExists BOOLEAN;
  DECLARE v_pendingPermissionExists BOOLEAN;
  DECLARE v_codeType INT;
  DECLARE v_startTime TIME;
  DECLARE v_endTime TIME;
  DECLARE v_timeDiff INT;
  DECLARE v_timeInDays DECIMAL(10,2);
  DECLARE v_carry DECIMAL(10,2) DEFAULT 0;
  DECLARE v_issueNumber INT;
  DECLARE v_id_reason_vacaciones INT;

  -- Obtener el id_codeType del empleado
  SELECT id_codeType INTO v_codeType FROM tb_employee WHERE id_employee = p_id_employee;
  
   -- Obtener el id_reason para "vacaciones"
  SELECT id_reason INTO v_id_reason_vacaciones FROM tb_reason
  WHERE LOWER(name_reason) LIKE '%vacaciones%';

  -- Verificar si existe un permiso pendiente
  SELECT EXISTS(
    SELECT 1
    FROM tb_permission
    WHERE id_employee = p_id_employee
    AND state_permission = 'P'
  ) INTO v_pendingPermissionExists;

  IF v_pendingPermissionExists = FALSE THEN

	IF p_id_reason = v_id_reason_vacaciones THEN
		-- Verificar si existe un periodo de vacaciones activo 
    	SELECT EXISTS(
      SELECT 1
      FROM tb_vacationPeriod 
      WHERE id_employee = p_id_employee
        AND state_vacationPeriod = TRUE 
    	) INTO v_vacationExists;
   ELSE 
   	SET v_vacationExists = TRUE;
	END IF;
   
    IF v_vacationExists = FALSE THEN
      SET message = 'No tiene periodo de vacaciones activo';
      SET success = FALSE;
    ELSE
    	-- Seleccionan el periodo más antiguo activo
      SELECT id_vacationPeriod, balanceDays_vacationPeriod, balanceWorkingDays_vacationPeriod, balanceWeekendDays_vacationPeriod
      INTO v_id_vacationPeriod, v_balanceDays, v_balanceWorkingDays, v_balanceWeekendDays
      FROM tb_vacationPeriod
      WHERE id_employee = p_id_employee AND state_vacationPeriod = TRUE 
      ORDER BY endDate_vacationPeriod ASC
      LIMIT 1;
      -- Obtener el id_numberPeriod activo
      SELECT id_numberPeriod
      INTO v_id_numberPeriod
      FROM tb_numberPeriod
      WHERE state_numberPeriod = TRUE;
      -- Validar si las fechas ingresadas son la misma, es decir para comprobar las horas
      IF DATE(p_startDate) = DATE(p_endDate) THEN
      	-- Validar que no sea dias de fin de semana (sábado o domingo)
      	IF WEEKDAY(p_startDate) <> 5 AND WEEKDAY(p_startDate) <> 6 THEN
	      	-- Validar el rango de horario según el id_codeType
	        IF v_codeType = 1 AND (TIME(p_startDate) < '08:00:00' OR TIME(p_endDate) > '16:30:00') THEN
	          SET message = 'Las horas seleccionadas no están de acuerdo a su horario. El rango de horario debe ser de 8:00 a 16:30.';
	          SET success = FALSE;
	        ELSEIF v_codeType = 2 AND (TIME(p_startDate) < '07:00:00' OR TIME(p_endDate) > '15:30:00') THEN
	          SET message = 'Las horas seleccionadas no están de acuerdo a su horario. El rango de horario debe ser de 7:00 a 15:30.';
	          SET success = FALSE;
	        ELSE
	          -- Verificar Rango de fecha y hora
	          IF TIME(p_startDate) >= TIME(p_endDate) THEN
	            SET message = 'El rango de hora es incorrecto.';
	            SET success = FALSE;
	          ELSE
	            -- Calcular la diferencia de tiempo en minutos
	            SET v_timeDiff = TIME_TO_SEC(TIMEDIFF(p_endDate, p_startDate)) / 60;
	            -- Convertir saldo de dias laborales en minutos
	            SET v_balanceWorkingDays = v_balanceWorkingDays * 8 * 60;     
	            -- Devuelve media hora si pide permiso en horario especifico y cuando pasa las 5 horas y media
		          IF (TIME(p_startDate) = '12:00:00' AND TIME(p_endDate) = '14:00:00') OR v_timeDiff = 330 OR v_timeDiff = 510 THEN
		            SET v_timeDiff = v_timeDiff - 30;
		          END IF;
		          -- Convertir la diferencia de tiempo en días
	            SET v_timeInDays = v_timeDiff / (8 * 60);
	            -- Verificar que si el tiempo de dia laboral no excede el saldo de dia laboral
	  				IF v_timeDiff > v_balanceWorkingDays THEN
	                SET message = CONCAT('Se excede en ', v_timeDiff - v_balanceWorkingDays , ' minutos del día laboral.');
	                SET success = FALSE;
	            ELSE 
	                SET v_workingDays = v_timeInDays;
	              	 SET success = TRUE;
	              	 
	              	 -- Control de dias laboales en caso de que sean vacaciones
		            IF p_id_reason = v_id_reason_vacaciones THEN
			            -- Obtener carry anterior
				          SET v_carry = (SELECT IFNULL((
							  SELECT carry_permission
							  FROM tb_permission
							  WHERE id_reason = v_id_reason_vacaciones AND id_employee = p_id_employee
							  ORDER BY id_permission DESC
							  LIMIT 1
							 ), 0));
								
							-- Validar si pasa de los 5 dias acumulados le descuente 2 dias de fines de semana
							IF (v_carry + v_workingDays) < 5 THEN 
								SET v_carry = v_carry + v_workingDays;
							ELSEIF (v_carry + v_workingDays) >= 5 AND v_balanceWeekendDays > 0 THEN
								SET v_weekendDays = 2;
								SET v_carry = (v_carry + v_workingDays) - 5;
							END IF;
		            END IF;
	            
	            END IF;
	            
	            IF success = TRUE THEN
	              INSERT INTO tb_permission (
	                id_employee,
	                id_reason,
	                id_numberPeriod,
	                issueDate_permission,
	                state_permission,
	                startDateTime_permission,
	                endDateTime_permission,
	                workingDays_permission,
	                weekendDays_permission,
	                carry_permission,
	                observation_permission
	              )
	              VALUES (
	                p_id_employee,
	                p_id_reason,
	                v_id_numberPeriod,
	                CURRENT_DATE(),
	                'P',
	                p_startDate,
	                p_endDate,
	                v_workingDays,
	                v_weekendDays,
	                v_carry,
	                p_observation_permission
	              );
	              -- Actualizar el contador en tb_numberPeriod
	              UPDATE tb_numberPeriod
	              SET count_numberPeriod = count_numberPeriod + 1
	              WHERE id_numberPeriod = v_id_numberPeriod;
	              -- Actualizar el estado de la fecha atrasado en caso de haber
	              UPDATE tb_permissionBack
	              SET state_permissionBack = 0
	              WHERE id_employee = p_id_employee AND state_permissionBack = 1;
	              -- Obtener contador actual
	              SELECT count_numberPeriod
				      INTO v_issueNumber
				      FROM tb_numberPeriod
				      WHERE id_numberPeriod = v_id_numberPeriod;
				     -- Actualizar numero de documento
				     SET @lastInsertId = LAST_INSERT_ID();
				     UPDATE tb_permission
				     SET issueNumber_permission = v_issueNumber
				     WHERE id_permission = @lastInsertId;
	  
	              SET message = 'Permiso solicitado exitosamente.';
	              SET success = TRUE;
	            END IF;
	            -- SET message = v_balanceWorkingDays;
	          END IF;
	        END IF;
      	ELSE
      		SET message = 'Solo aplica para dias laborables';
          	SET success = FALSE;
		END IF;
      ELSE
        -- Verificar Rango de fecha
        IF DATE(p_startDate) > DATE(p_endDate) THEN
          SET message = 'El rango de fechas es incorrecto.';
          SET success = FALSE;
        ELSE
          SET v_workingDays = 0;
          SET v_weekendDays = 0;
          SET v_tempDate = DATE(p_startDate);
  
          -- Calcular los dias laborales y fines de semana
          WHILE v_tempDate <= DATE(p_endDate) DO
            IF WEEKDAY(v_tempDate) BETWEEN 0 AND 4 THEN
              SET v_workingDays = v_workingDays + 1;
            ELSEIF WEEKDAY(v_tempDate) IN (5, 6) THEN
              SET v_weekendDays = v_weekendDays + 1;
            END IF;
            SET v_tempDate = DATE_ADD(v_tempDate, INTERVAL 1 DAY);
          END WHILE;
			
          -- Verificar que si los dias laborales y fines de semanas no exceden del saldo de dias.
          IF (v_workingDays + v_weekendDays) > v_balanceDays THEN
            SET message = CONCAT('Se excede en ',v_balanceDays - (v_workingDays + v_balanceWeekendDays), ' día(s).');
            SET success = FALSE;
          ELSE
             -- Control de dias laboales en caso de que sean vacaciones
		      IF p_id_reason = v_id_reason_vacaciones THEN
			   -- Obtener carry anterior
					SET v_carry = (SELECT IFNULL((
					SELECT carry_permission
					FROM tb_permission
					WHERE id_reason = v_id_reason_vacaciones AND id_employee = p_id_employee
					ORDER BY id_permission DESC
				 	LIMIT 1
					), 0));
								
					-- Validar si pasa de los 5 dias acumulados le descuente 2 dias de fines de semana
					IF (v_carry + v_workingDays) < 5 THEN 
						SET v_carry = v_carry + v_workingDays;
					ELSEIF (v_carry + v_workingDays) >= 5 AND v_workingDays <= 5 AND v_balanceWeekendDays > 0 THEN
						SET v_weekendDays = 2;
						SET v_carry = (v_carry + v_workingDays) - 5;
					END IF;
					
					-- Validar si los fines de semana exceden al saldo de fines de semana
					IF v_weekendDays > v_balanceWeekendDays THEN
						SET v_workingDays = v_workingDays + (v_weekendDays - v_balanceWeekendDays);
						SET v_weekendDays = v_balanceWeekendDays;
					END IF;
		      END IF;
	         
            INSERT INTO tb_permission (
              id_employee,
              id_reason,
              id_numberPeriod,
              issueDate_permission,
              state_permission,
              startDateTime_permission,
              endDateTime_permission,
              workingDays_permission,
              weekendDays_permission,
              carry_permission,
              observation_permission
            )
            VALUES (
              p_id_employee,
              p_id_reason,
              v_id_numberPeriod,
              CURRENT_DATE(),
              'P',
              p_startDate,
              p_endDate,
              v_workingDays,
              v_weekendDays,
              v_carry,
              p_observation_permission
            );
            
            -- Actualizar el contador en tb_numberPeriod
            UPDATE tb_numberPeriod
            SET count_numberPeriod = count_numberPeriod + 1
            WHERE id_numberPeriod = v_id_numberPeriod;
            -- Actualizar el estado de la fecha atrasado en caso de haber
	         UPDATE tb_permissionBack
	         SET state_permissionBack = 0
	         WHERE id_employee = p_id_employee AND state_permissionBack = 1;
	         -- Obtener contador actual
	         SELECT count_numberPeriod
				INTO v_issueNumber
				FROM tb_numberPeriod
				WHERE id_numberPeriod = v_id_numberPeriod;
				-- Actualizar numero de documento
				SET @lastInsertId = LAST_INSERT_ID();
				UPDATE tb_permission
				SET issueNumber_permission = v_issueNumber
				WHERE id_permission = @lastInsertId;
  
            SET message = 'Permiso solicitado exitosamente.';
            SET success = TRUE;
          END IF;
        END IF;
      END IF;
    END IF;
  ELSE
    SET message = 'Ya existe un permiso pendiente, espere una respuesta';
    SET success = FALSE;
  END IF;
  
END $$

DELIMITER ;










DELIMITER $$

CREATE PROCEDURE pa_updatePermissionState(
  IN p_id_permission INT,
  IN p_state CHAR(1),
  IN p_message VARCHAR(255),
  OUT message VARCHAR(255),
  OUT success BOOLEAN
)
BEGIN
  DECLARE v_id_employee INT;
  DECLARE v_id_reason INT;
  DECLARE v_workingDays DECIMAL(10,2);
  DECLARE v_weekendDays DECIMAL(10,2);
  DECLARE v_id_vacationPeriod INT;
  DECLARE v_state_permission CHAR(1);
  DECLARE v_id_reason_vacaciones INT;
  DECLARE v_carry_now INT;
  DECLARE v_carry INT DEFAULT 0;

  -- Obtener el id_reason para "vacaciones"
  SELECT id_reason INTO v_id_reason_vacaciones
	FROM tb_reason
	WHERE LOWER(name_reason) LIKE '%vacaciones%';

  -- Obtener los detalles del permiso
  SELECT id_employee, id_reason, workingDays_permission, weekendDays_permission, state_permission, carry_permission
  INTO v_id_employee, v_id_reason, v_workingDays, v_weekendDays, v_state_permission, v_carry_now
  FROM tb_permission
  WHERE id_permission = p_id_permission;

  -- Obtener el id_vacationPeriod activo más antiguo
  SELECT id_vacationPeriod
  INTO v_id_vacationPeriod
  FROM tb_vacationPeriod
  WHERE id_employee = v_id_employee AND state_vacationPeriod = TRUE
  ORDER BY endDate_vacationPeriod ASC
  LIMIT 1;

  -- Si el estado es cambiado a Validado y el estado previo es Pendiente
  IF (p_state = 'V' AND v_state_permission = 'P') OR (p_state = 'V' AND v_state_permission = 'R') THEN
    
    -- Comprobar si id_reason corresponde a "vacaciones" antes de realizar descuentos
    IF v_id_reason = v_id_reason_vacaciones THEN
    		IF p_state = 'V' AND v_state_permission = 'P' THEN
    			SET v_carry = v_carry_now;
    		ELSEIF p_state = 'V' AND v_state_permission = 'R' THEN
    			IF (v_workingDays + v_carry_now) >= 5 THEN
    				SET v_carry = (v_workingDays + v_carry_now) - 5;
    			ELSE
    				SET v_carry = v_carry_now + v_workingDays;
    			END IF;
    		END IF;
    		
        UPDATE tb_vacationPeriod
        SET balanceDays_vacationPeriod = balanceDays_vacationPeriod - (v_workingDays + v_weekendDays),
            balanceWorkingDays_vacationPeriod = balanceWorkingDays_vacationPeriod - v_workingDays,
            balanceWeekendDays_vacationPeriod = balanceWeekendDays_vacationPeriod - v_weekendDays,
            state_vacationPeriod = balanceWorkingDays_vacationPeriod > 0
        WHERE id_vacationPeriod = v_id_vacationPeriod;
    END IF;
    
    UPDATE tb_permission
    SET state_permission = p_state,
    		carry_permission = v_carry,
        adminObservation_permission = p_message
    WHERE id_permission = p_id_permission;

    SET message = 'Permiso validado exitosamente.';
    SET success = TRUE;

  -- Si el estado es cambiado a Rechazado y el estado previo es Aprobado
  ELSEIF p_state = 'R' AND v_state_permission = 'V' THEN
    -- Comprobar si id_reason corresponde a "vacaciones" antes de realizar la devolución
    IF v_id_reason = v_id_reason_vacaciones THEN
     		
     		SET @count_permiss = (SELECT COUNT(*) FROM tb_permission
			WHERE id_reason = v_id_reason_vacaciones AND id_employee = v_id_employee); 
			
			IF @count_permiss > 1 THEN
				 -- Obtener carry anterior
				SET v_carry = (SELECT carry_permission FROM tb_permission WHERE id_permission <> p_id_permission 
				AND id_reason = v_id_reason_vacaciones AND id_employee = v_id_employee
				ORDER BY id_permission DESC LIMIT 1);
			END IF;
								
        UPDATE tb_vacationPeriod
        SET balanceDays_vacationPeriod = balanceDays_vacationPeriod + (v_workingDays + v_weekendDays),
            balanceWorkingDays_vacationPeriod = balanceWorkingDays_vacationPeriod + v_workingDays,
            balanceWeekendDays_vacationPeriod = balanceWeekendDays_vacationPeriod + v_weekendDays,
            state_vacationPeriod = balanceWorkingDays_vacationPeriod > 0
        WHERE id_vacationPeriod = v_id_vacationPeriod;
    END IF;
    
    UPDATE tb_permission
    SET state_permission = p_state,
    		carry_permission = v_carry,
        adminObservation_permission = p_message
    WHERE id_permission = p_id_permission;

    SET message = 'Permiso rechazado y cambios revertidos.';
    SET success = TRUE;

  -- Si el estado es cambiado a Rechazado y el estado previo es Pendiente
  ELSEIF p_state = 'R' AND v_state_permission = 'P' THEN
    -- En caso de ser vacaciones aplica la logica del carry
		IF v_id_reason = v_id_reason_vacaciones THEN
			
			SET @count_permiss = (SELECT COUNT(*) FROM tb_permission
			WHERE id_reason = v_id_reason_vacaciones AND id_employee = v_id_employee); 
			
			IF @count_permiss > 1 THEN
				 -- Obtener carry anterior
				SET v_carry = (SELECT carry_permission FROM tb_permission WHERE id_permission <> p_id_permission 
				AND id_reason = v_id_reason_vacaciones AND id_employee = v_id_employee
				ORDER BY id_permission DESC LIMIT 1);
			END IF;
			   
		END IF;

	   UPDATE tb_permission
      SET state_permission = p_state,
      	carry_permission = v_carry,
        adminObservation_permission = p_message
      WHERE id_permission = p_id_permission;

      SET message = 'Permiso rechazado.';
      SET success = TRUE;

  ELSE
    SET message = 'Transición de estado no válida.';
    SET success = FALSE;
  END IF;

END $$

DELIMITER ;


-- -------------------------------------------------------------------------------------------

DELIMITER $$

CREATE PROCEDURE pa_insertPermissionBack(
    IN id_employee INT,
    IN minDate_permissionBack DATE,
    IN state_permissionBack BOOLEAN,
    OUT message VARCHAR(255),
    OUT success BOOLEAN
)
BEGIN
    DECLARE error INT DEFAULT 0;
    DECLARE employeeCount INT DEFAULT 0;
    
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        SET error = 1;
        SET message = 'Error al insertar el registro en tb_permissionBack.';
        SET success = FALSE;
    END;
    
    START TRANSACTION;
    
    -- Verificar si el id_employee existe
    SELECT COUNT(*) INTO employeeCount FROM tb_employee WHERE id_employee = id_employee;
    
    IF employeeCount = 0 THEN
        SET message = 'El id_employee no existe.';
        SET success = FALSE;
        SET error = 1;
    ELSE
        SET @issueDate_permissionBack = CURRENT_TIMESTAMP();
        
        INSERT INTO tb_permissionBack (id_employee, issueDate_permissionBack, minDate_permissionBack, state_permissionBack)
        VALUES (id_employee, @issueDate_permissionBack, minDate_permissionBack, state_permissionBack);
        
        IF error = 0 THEN
            COMMIT;
            SET message = 'El registro se insertó correctamente';
            SET success = TRUE;
        ELSE
            ROLLBACK;
        END IF;
    END IF;
    
END $$

DELIMITER ;


DELIMITER $$

CREATE PROCEDURE pa_updatePermissionBack(
    IN p_id_permissionBack INT,
    IN p_minDate_permissionBack DATE,
    IN p_state_permissionBack BOOLEAN,
    OUT message VARCHAR(255),
    OUT success BOOLEAN
)
BEGIN
    DECLARE error INT DEFAULT 0;
    DECLARE permissionCount INT DEFAULT 0;
    
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        SET error = 1;
        SET message = 'Error al insertar el registro en tb_permissionBack.';
        SET success = FALSE;
    END;
    
    START TRANSACTION;
    
    -- Verificar si el p_id_permissionBack existe
    SELECT COUNT(*) INTO permissionCount FROM tb_permissionBack WHERE id_employee = id_employee;
    
    IF permissionCount = 0 THEN
        SET message = 'El id_permissionBack no existe.';
        SET success = FALSE;
        SET error = 1;
    ELSE
        
        UPDATE tb_permissionback SET
		 minDate_permissionBack = p_minDate_permissionBack, 
		 state_permissionBack = p_state_permissionBack
      WHERE id_permissionBack = p_id_permissionBack;
        
        IF error = 0 THEN
            COMMIT;
            SET message = 'Se actualizó correctamente';
            SET success = TRUE;
        ELSE
            ROLLBACK;
        END IF;
    END IF;
    
END $$

DELIMITER ;





DELIMITER $$

CREATE PROCEDURE pa_getPermissionBackDate(
  IN p_id_employee INT,
  OUT p_date_permissionBack DATETIME
)
BEGIN
  DECLARE v_exist INT;

  -- Verificar si existe un registro con el id_employee y state específicos
  SELECT COUNT(*) INTO v_exist
  FROM tb_permissionBack
  WHERE id_employee = p_id_employee AND state_permissionBack = 1;

  IF v_exist > 0 THEN
    -- Obtener la fecha del registro correspondiente
    SELECT minDate_permissionBack INTO p_date_permissionBack
    FROM tb_permissionBack
    WHERE id_employee = p_id_employee AND state_permissionBack = 1;
  ELSE
    -- No existe un registro válido, retornar la fecha actual
    SET p_date_permissionBack = NOW();
  END IF;
END $$

DELIMITER ;

